# Documentation
We decided to write our documentation in Markdown, as it is a simple plaintext format, ensuring that you should be able to view and edit the files on almost any machine. As a text file, it is as lightweight as you can get for the given amount of information.
It has advantages over plaintext, since its annotations and formatting options result in a more well structured and comprehensible document. Additionally, Github has a built-in Markdown viewer, ensuring that the document will be viewable in rendered form from any computer with a browser and access to the repo.
We decided against proprietary file types like .doc(x), since not everyone may have access to the software to read those files, and relying on such file formats leaves us susceptible to vendor lock-in. Such file formats cannot be managed by VCS, and tend to take up significantly more storage space as well.
# CI/CD
For our Javascript and Python code formatters, we chose Prettier and Black respectively. Both are chosen for popularity, providing the highest likelihood that code will be in a format other developers are familiar with, increasing the speed with which they can understand the codebase. Prettier has an astounding 25 million downloads for its VS Code plugin alone, while Black has almost 30 thousand stars on its Github repo. Both are opinionated, meaning we spend less time on trivial formatting conventions, and more time on actual product development.
We also intend to use Github Actions, due to its obvious tight integration with Github, and its ability to run actions on multiple OSes. Since it is managed by Github, we avoid the overhead of deploying and administering a self-hosted CI/CD platform like Jenkins, and it is also free to use.
# Packaging
We decided to use some containerization technology to build and package our application, allowing us to fulfil the requirement of having to run across multiple platforms more easily. We decided to use Docker, as one of the leading containerization tools. Containers are more lightweight than VMs, allowing us to build and iterate more rapidly, especially when potentially running multiple containers on resource constrained machines.
We are using Docker Compose for container orchestration, as an extension of Docker using a simple YAML syntax. It is bundled together with Docker, allowing us to simplify the development environment install process, reducing dependencies and complexity. It offers enough control for our purposes, while taking far less effort to manage than something like Kubernetes.
# Database
PostgreSQL will be our database of choice.  This choice piggybacks off the choice of our backend coding language and in particular, our choice of using Python with the Django framework.
According to the official Django docs located at https://docs.djangoproject.com/en/4.1/ref/databases/, PostgreSQL is among the officially supported databases of the Django framework.  This gives us assurance, as this means that the Django developers have their framework tested with PostgreSQL; minimising any incompatibility issues between the two software.
But why not pick among the other supported databases such as MariaDB and MySQL?  From our research,  there are not enough differences between these SQL databases that warrant us to pick one over another due to some major advantages/disadvantages which one has.  The choice basically boiled down preferences.
As it turns out, all three group members have used PostgreSQL.  It is the natural choice, as familiarity will speed up development time and minimise errors.
# Backend
The backend will consist of two main components: the API component and the data processing component (which contains logic for purposes such as mathematical operations and graph generation).  The backend as a whole (both components) will be written in Python.
Henry has experience writing backends in JavaScript mainly, while Qi En and Chaoyu have experience mainly with Python backends.  While the majority of the members are more comfortable with Python, this doesn’t automatically preclude JavaScript, or other languages to write our backend with as those may be worth the effort to learn if it is best suited for our application.
However, we have strong reasons for why the data processing component should be written in Python.  Through our years of using Python for various mathematical and development applications, we know that there are powerful data processing libraries available for Python.  
Our preliminary idea for what to do with the data stream would be to generate a “correlation graph“.  Qi En says this graph can be generated directly with the matplotlib library for Python.  This reason alone is enough for us to go with Python.  In addition, the fact that Python is the most popular language for data science (as noted here https://www.datacamp.com/blog/top-programming-languages-for-data-scientists-in-2022) gives us assurance that Python already have a lot of features that we need baked into various libraries which we can leverage.  These features include data parsing and data interpretation.  There may also be additional data related features, which Python probably have the highest chance of having, which we may need, but have not yet uncovered at this stage.
For the purposes of simplifying integration, It naturally follows that we’d want the data processing component to be written in Python as well.  This way, we can have Python processes for the backend as a whole; allowing the data processor to communicate with the API in Python data-types.
We will be using the Django framework for the API, which Qi En and Chaoyu are most comfortable with.  There are drawbacks with this setup over other setups, particularly to a node.js/express.js setup.  According to https://www.simform.com/blog/express-vs-django/, Django is not able to handle as many requests, as frequently as express.js.  This is because express.js processes asynchronous requests better than Django.  In addition, Django is not as scalable as express.js.
These factors will not be enough to dissuade us from using Django, as our application will be small, and will most likely be accessed by ~3 people at a time, at most (not too much need for processes asynchronous requests).  The scalability factor will not be an issue for us, as we will be perfectly content with keeping the application small and manageable.
# Frontend
We decided to build our frontend as a separate server using Javascript/React. The advantages include a large ecosystem of npm packages, up-to-date and long term support from React developers, and a large existing community that have likely posted answers to common questions that we will run into. Additionally, all members of our team have previous exposure to React, allowing us to minimise learning time.
We have also discussed using alternative frameworks such as Angular. However, our team is more experienced in React than any other framework. Given the tight time constraints, we decided that React is the most suitable framework.
We considered using Django to render web templates so that the Django server may act as both frontend and backend. This cuts down integration difficulty as well as simplifies our codebase. However, using templating languages is more restrictive feature-wise than what is possible with Javascript webapps. Given that we are still in early stages of development and that many technical details have yet to be determined, we decided against this approach so that we can keep our options flexible.
# Hosting/SaaS
We considered using cloud based no-sql databases such as DynamoDB. However, we decided that the added workload of setting up, managing credentials, and managing cloud resources are not worth the benefit, as the scope of the project doesn’t require long-term maintenance and scalability.
Given that we are in early stages of development, it is possible that we may adopt various SaaS services as the development progresses. However, for reasons stated above, we will only consider these options if absolutely necessary.
